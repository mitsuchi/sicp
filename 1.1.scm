; 1.1 プログラムの要素
; ====================
; 
; よくできたプログラム言語は、ただコンピュータに命令をするだけじゃなくて
; 考え方のフレームワークになる。
; 言語をみるときは、小さいアイデアを複雑なアイデアに組み立てるための手段に
; 注目するといい。
; よくできた言語はそのための3つの方法を必ず持っている
;
; 基本要素        ：一番かんたんな要素、3とか"hoge"とか
; 組み合わせの手段：かんたんな要素から複雑な要素をつくる方法
; 抽象化の手段    ：複雑な要素に名前をつけて、単位として扱う手段
;
; プログラムでは2つのことを扱う。手続きとデータだ。
; データは「もの」。手続きはものの扱いかた。
; 簡単なデータから複雑なデータをつくるやり方や
; 簡単な手続きから複雑な手続きをつくるやり方が必ずある。
;
; この章では簡単のためにデータとして数値だけを扱う。
; 複雑なデータでも、同様に手続きをつくれることが後で分かる。
;
; 1.1.1 式
; --------
;
; Scheme に慣れるために、インタープリターに式を食わせてみよう。
; 基本要素の1つは、数値だ。

486

; は、486と返す。
; 数値は、基本手続きである * とか + を使って、複合した式にできる。

(+ 137 349)
486
(- 1000 334)
666
(* 5 99)
495
(/ 10 5)
2
(+ 2.7 10)
12.7

; など。
; 手続きの適用のためのこういう式をコンビネーションという。
; 一番左の要素がオペレーター、その他はオペランドという。
; コンビネーションの値は、オペレーターで表される手続きに、
; オペランドの値を適用して得られる。
;
; オペレーターが一番左にあるような記法を前置記法という。
; 利点の1つは、引数がどれだけ長くてもいいこと。

(+ 21 35 12 7)
75

(* 25 4 12)
1200

; 2つ目の利点は、コンビネーションそのままネストできること。

(+ (* 3 5) (- 10 6))
19

; ネストの深さには原理的には制限がない。

(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))

; って書くと混乱するけど、インタープリターにとっては問題ない。
; 人間用の表記として、

(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))

; みたいにインデントすると見やすい。
; どんなに複雑な式でも、インタープリターがそれを扱う方法は決まってる。
; 式を読み取って、評価して、値を出力する。
; こういうモードを REPL -- read-eval-print loop という。
;
; 1.1.2 名前と環境
; ----------------
;
; 計算の対象となるオブジェクトに名前をつけることができる。
; 名前は変数を区別する。変数の値はオブジェクトだ。

(define size 2)

; とすると、2という値にsizeという名前がひもづけられる。
; すると size という名前でその値を参照できる。

size
2
(* 5 size)
10

; その他の例。

(define pi 3.14159)
(define radius 10)
(* pi (* radius radius))
314.159
(define circumference (* 2 pi radius))
circumference
62.8318

; defineは、もっとも簡単な抽象化の手段だ。
; 複雑な結果にかんたんな名前をつけることができる。
;
; 計算のステップが進むほど、オブジェクトは複雑になっていく。
; それらに名前をつけて単位として扱うことで一歩ずつプログラムを
; 組んで行くことができる。
;
; 名前と値をひもづけておくためのメモリーのことを環境という。
; 環境は複数つくられる。ここまでの例の場合は正確にはグローバル環境という。

; 1.1.3 コンビネーションを評価する
;
; コンビネーションを評価するとき、インタープリター自体がある手続きに従う。
;
; 1. コンビネーションに含まれる部分式を評価する
; 2. 一番左の部分式（オペレーター）の値に、その他の部分式の値を適用する
;
; このルールは再帰的なことに注意。
; 深くネストした計算は、ふつうのやりかただととても複雑になるけど再帰だと
; 簡単。たとえば、

(* (+ 2 (* 4 6))
   (+ 3 5 7))

; の評価の過程を図に書くと木のようになる。
;
; *
;   +
;     2
;     *      
;       4
;       6
;   +
;     3
;     5
;     7
;
; 部分評価の結果が木を登って行く感じ。
; こういうのを再帰で処理するのは簡単で、一般に木のアキュミュレーションという。
;
; 再帰の過程で基本要素を評価することになって、そこが末端になる。
; それは3パターンある。
;
; 1. 数の値はそれ自身が表す値
; 2. 組み込みオペレーターの値は、それを処理する機械語の列
; 3. 変数の値は、環境中にひもづけられたオブジェクト
;
; 2つめは3つめの特別な値ともいえる。組み込みオペレーターがグローバル環境中に
; 定義されてると考えれば。環境がないと + がなにかともいえないのでとにかく重要。
;
; ただし上で書いた評価方法は、defineには使えない。

(define x 3)

; は define に x と 3 を適用するわけじゃないから。
; こういうのはスペシャルフォームといって、それぞれ評価の方法が違う。
; define のほかにも後々でてくる。

; 1.1.4 複合手続き
; --------------------
;
; これまでに重要な要素を3つ見てきた。
;
; 1. 数値と数値計算関数は基本的なデータと手続きだ
; 2. 手続きを組み合わせるには、コンビネーションをネストさせればいい
; 3. defineによる名前づけは抽象化の1つの手段
;
; こんどは関数定義について学ぶ。複雑な手続きに名前をつけて抽象化する
; 強力な手段だ。
;
; たとえば何かを2乗する関数はこう。

(define (square x) (* x x))

; これは、なにかを2乗するためには、その数どうしをかけなさいと読める。
; こういう square みたいのを複合手続きという。
; この define を評価すると、複合手続きをつくって、それに square という
; 名前を環境内でひもづける。
;
; 関数定義の一般的な形はこう。

(define (<name> <formal parameters>) <body>)

; <name>は関数にひもづいて環境に定義される名前、<formal parameters>は、
; 関数の本体で引数の値にひもづく名前、<body> は関数本体を表す式。
;
; squareをつかってみよう。

(square 21)
441

(square (+ 2 5))
49

(square (square 3))
81

; square を組み立ての単位とすることもできる。
; x^2 + y^2 はこう。

(+ (square x) (square y))

; それを表す関数はこうなる。

(define (sum-of-squares x y)
  (+ (square x) (square y)))

(sum-of-squares 3 4)
25

; sum-of-squares を単位とすることすらできる。

(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))

(f 5)
136

; 複合手続きは基本手続きとまったく同じように使われ、
; 外部からそれらを区別することはできない。

; 1.1.5 置き換えモデルによる関数の適用
; 
; 基本手続きの処理はインタープリターに組み込まれてるとして、
; 複合手続きの処理は置き換えで考えることができる。
;
; つまり、複合手続きに引数を適用するには、手続きの本体にでてくる
; パラメーターを引数で置き換えればいい。
;
; 例えば次の式で考えてみよう。n

(f 5)

; f の本体は

(sum-of-squares (+ a 1) (* a 2))

; なので、この a を 5で置き換えると

(sum-of-squares (+ 5 1) (* 5 2))

; になる。まず引数の部分式を先に評価して

(sum-of-squares 6 10)

; sum-of-squares の本体は

(+ (square x) (square y))

; だったから置き換えると

(+ (square 6) (square 10))

; 部分式を先に評価すると、square の本体は

(* x x)

; だったから、

(+ (* 6 6) (* 10 10))

; で

(+ 36 100)

; になって

136

; が答というわけ。こういうのを関数適用の置き換えモデルという。
; ここまでにでてきた関数においては、関数の適用の意味はこれでいい。
;
; ただし次の点に注意する。
; 1. ほんとにこの通りインタープリターが評価してるわけじゃに。
; 2. 置き換えモデルは、計算のモデルの一歩目にすぎない。
;    この後だんだんモデルを紹介して、そのたび実際のモデルに近づいていく。
;    たとえばこの後でやるミュータブルなデータだと置き換えモデルは破綻する。
; 
; 適用順と正規順
; --------------
;
; さっきはオペランドを先に評価したけど、後から評価してもいいはず。
; 具体的には基本手続きまで展開されたらはじめて評価することもありうる。

(f 5)

; で試すとこうなる。

(sum-of-squares (+ 5 1) (* 5 2))

(+    (square (+ 5 1))      (square (* 5 2))  )

(+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))

; ここで (+ 5 1 ) とかが基本手続きまで展開されつくしたので
; いよいよ評価していく。

(+         (* 6 6)             (* 10 10))

(+           36                   100)

                    136

; 同じ答えがでたけど、評価の過程は違ってる。
; とくに (+ 5 1)とかは2回も評価してる。
;
; こういうふうに、展開しきってから収束させるのを正規順という。
; これまでの、引数を評価してから適用させるのは適用順という。
; 置き換えモデルが有効な限り、どっちの順序も処理結果は同じ。
;
; Lispは適用順を使う。ひとつには、(+ 5 1)を2回評価するみたいな
; ムダを省きたいので。それに正規順での評価は一般的にはとても
; 複雑になりうる。でも正規順も強力なツールになるので後で扱う。
