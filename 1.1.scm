; 1.1 プログラムの要素
; ====================
; 
; よくできたプログラム言語は、ただコンピュータに命令をするだけじゃなくて
; 考え方のフレームワークになる。
; 言語をみるときは、小さいアイデアを複雑なアイデアに組み立てるための手段に
; 注目するといい。
; よくできた言語はそのための3つの方法を必ず持っている
;
; 基本要素        ：一番かんたんな要素、3とか"hoge"とか
; 組み合わせの手段：かんたんな要素から複雑な要素をつくる方法
; 抽象化の手段    ：複雑な要素に名前をつけて、単位として扱う手段
;
; プログラムでは2つのことを扱う。手続きとデータだ。
; データは「もの」。手続きはものの扱いかた。
; 簡単なデータから複雑なデータをつくるやり方や
; 簡単な手続きから複雑な手続きをつくるやり方が必ずある。
;
; この章では簡単のためにデータとして数値だけを扱う。
; 複雑なデータでも、同様に手続きをつくれることが後で分かる。
;
; 1.1.1 式
; --------
;
; Scheme に慣れるために、インタープリターに式を食わせてみよう。
; 基本要素の1つは、数値だ。

486

; は、486と返す。
; 数値は、基本手続きである * とか + を使って、複合した式にできる。

(+ 137 349)
486
(- 1000 334)
666
(* 5 99)
495
(/ 10 5)
2
(+ 2.7 10)
12.7

; など。
; 手続きの適用のためのこういう式をコンビネーションという。
; 一番左の要素がオペレーター、その他はオペランドという。
; コンビネーションの値は、オペレーターで表される手続きに、
; オペランドの値を適用して得られる。
;
; オペレーターが一番左にあるような記法を前置記法という。
; 利点の1つは、引数がどれだけ長くてもいいこと。

(+ 21 35 12 7)
75

(* 25 4 12)
1200

; 2つ目の利点は、コンビネーションそのままネストできること。

(+ (* 3 5) (- 10 6))
19

; ネストの深さには原理的には制限がない。

(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))

; って書くと混乱するけど、インタープリターにとっては問題ない。
; 人間用の表記として、

(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))

; みたいにインデントすると見やすい。
; どんなに複雑な式でも、インタープリターがそれを扱う方法は決まってる。
; 式を読み取って、評価して、値を出力する。
; こういうモードを REPL -- read-eval-print loop という。
;
; 1.1.2 名前と環境
; ----------------
;
; 計算の対象となるオブジェクトに名前をつけることができる。
; 名前は変数を区別する。変数の値はオブジェクトだ。

(define size 2)

; とすると、2という値にsizeという名前がひもづけられる。
; すると size という名前でその値を参照できる。

size
2
(* 5 size)
10

; その他の例。

(define pi 3.14159)
(define radius 10)
(* pi (* radius radius))
314.159
(define circumference (* 2 pi radius))
circumference
62.8318

; defineは、もっとも簡単な抽象化の手段だ。
; 複雑な結果にかんたんな名前をつけることができる。
;
; 計算のステップが進むほど、オブジェクトは複雑になっていく。
; それらに名前をつけて単位として扱うことで一歩ずつプログラムを
; 組んで行くことができる。
;
; 名前と値をひもづけておくためのメモリーのことを環境という。
; 環境は複数つくられる。ここまでの例の場合は正確にはグローバル環境という。

; 1.1.3 コンビネーションを評価する
