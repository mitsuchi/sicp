1.2 手続きと、それがつくるプロセス
==================================

これまでプログラムの要素をみてきたけど、これだけだとまだプログラムが組めるようになったとはいえない。チェスでいえば駒の動かし方が分かっただけで、どう動せばいいかが分からないからだ。

達人になるには、何をどう動かしたらその結果何がどうなるかが完璧に分かってないといけない。あらかじめ図示できるようじゃないといけない。

手続きは、計算のプロセスの局所的な進行のパターンだ。あるステージから次のステップでどんなステージになるかを定める。

この章では、かんたんな手続きについて、典型的な計算のプロセスの形を見てみよう。
それから計算量とか領域量も。

1.2.1 線形再帰と繰り返し
------------------------

最初に階乗の計算プロセスを見てみよう。
```lisp
(factorial 6)
(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (factorial 3))))
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
720
```
たとえばこんな感じだ。factorial はふつうに定義するとこうなる。
```lisp
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
```
もうちょっと違う計算方法もある。
1 * 2 * .. * n みたいに1から順にnまでかけ算すればいい。
こんな感じ。
```lisp
(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
```
計算のプロセスはこうだ。
```lisp
(factorial 6)
(fact-iter   1 1 6)
(fact-iter   1 2 6)
(fact-iter   2 3 6)
(fact-iter   6 4 6)
(fact-iter  24 5 6)
(fact-iter 120 6 6)
(fact-iter 720 7 6)
720
```
fact-iterの最初の引数に途中の答えが引き回されてる。2番めの引数はカウンターだ。
ふたつの factorial は、同じ計算をする手続きなのにそのプロセスは全然違う。

最初の例みたいに、最初に展開しまくって後から収束するタイプを再帰的プロセスという。
展開してる最中に必要な領域はnに比例するので、とくに線形再帰プロセスという。

2つめのほうは、必要な領域量はプロセスの最中ずっと一定だ。こういうのを繰り返しプロセスという。この手のプロセスの状態は状態変数と、それがどういうふうに変化するか、どんな条件で繰り返しが終わるかで表せる。
n!を計算するのに必要なステップはnなので、とくに線形繰り返しプロセスという。

見方をかえるとこういう違いもある。繰り返しプロセスのほうは、プロセスの状態は手続きに含まれる変数の値で完全に決まる。途中で中断しても、すべての変数の値が分かってれば、そこから再開できる。でも再帰的プロセスのほうは、再帰がどこまで進んでるかっていう表にでない情報があって、それがないと中断したあと再開できない。

再帰的手続きと再帰的プロセスは区別しないといけない。再帰的手続きのほうは、文法的に手続きが自分自身を呼び出してること。再帰的プロセスは、プロセスが展開〜収束みたいに進行すること。たとえば fact-iter は、再帰的手続きだけど再帰的プロセスじゃない。

ふつうの言語だと、再帰的手続きはかならず再帰的プロセスになる。繰り返しプロセスにしようと思ったら while とかのループ用の部品を使わないといけない。
schemeの場合は、再帰的手続きでも繰り返しプロセスになる場合があって、そういう実装を末尾再帰という。

### 問題 1.9

次の2つの手続きは、足し算を定義してる。inc(1足す)とdec(1引く)を使ってる。
```lisp
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
```
置き換えモデルを使って、(+ 4 5)の評価プロセスがどう進むかしらべなさい。
再帰的？それとも繰り返し？

[回答](exercises/1.9.scm)

### 問題 1.10

次の手続きはアッカーマン関数というものを計算する。
```lisp
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
```
次の式の値は？
```lisp
(A 1 10)

(A 2 4)

(A 3 3)
```
それから次の手続きの計算する関数の数学的な定義をあたえなさい。
```lisp
(define (f n) (A 0 n))

(define (g n) (A 1 n))

(define (h n) (A 2 n))

(define (k n) (* 5 n n))
```
[回答](exercises/1.10.scm)

木の再帰
--------

もうひとつよくあるパターンは木の再帰だ。
フィボナッチ数列を考えてみる。ある項は前2つの和だ。
```lisp
0,1,1,2,3,5,8,13,21,...
```
手続きで表すとこう。
```lisp
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
```
計算のプロセスは木みたいになる
```lisp
fib 4
  fib 3
    fib 2
      fib 1
        1
      fib 0
        0
    fib 1
      1
  fib 2
    fib 1
      1
    fib 0
      0
```
木は2分木になっていて、つまりfibは1ステップ進むたびに2回呼び出される。
ただこの定義はムダが多い。fib 4でみると、fib 2 は2回、fib 1は３回も重複して計算されてる。

実際、fib n を計算する過程で fib 0 と fib 1は合計Fib(n+1)回計算される。
Fib(n) はnの指数関数的に増えるので、つまりfib nの計算に必要なステップも指数関数的ということになる。ちなみに黄金比をφとすると、φ^√5に一番近い自然数がFib(n)になる。

領域量のほうは実は線形でいい。なぜなら再帰の深さは木の深さになるけど、それはせいぜい n だから。

一般に木の再帰では、計算のステップ数は木のノードの数に比例して、領域量は木の深さに比例する。

フィボナッチ数を繰り返し的プロセスで計算することもできる。
それぞれのステップで Fib(n)とFib(n+1)を覚えておけばいい。
```lisp
(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))
```
fib-iter の a が Fib(n+1)で、bがFib(n)にあたる。
こっちだと計算のステップ数はnに比例する。

だからといって、木の再帰的プロセスは使えないと思っちゃ行けない。
木構造の上で計算するときにはまっすぐで分かりやすいし、数学的な定義からLispへの変換も簡単だ。繰り返しプロセスへの変換は簡単じゃない場合がある。

### 例：両替する方法を数える

フィボナッチ数の場合は繰り返しプロセスで表すのはちょっとした工夫でよかった。
次の場合はどうだろう？

1ドルを両替するのに何通りの方法があるか？使う硬貨は次のとおり。
* ハーフダラー：1/2ドル
* クォーター　：1/4ドル
* ダイム　　　：1/10ドル
* ニッケル　　：1/20ドル
* ペニー　　　：1/100ドル

再帰的手続きだと簡単な解法がある。いま使える硬貨の種類が順番に並んでるとして、aドルをn種類の硬貨で両替する方法の数は次の2つの和に等しい。

* A. aドルを最初の硬貨を使わないで両替する方法の数　
* B. a-dドルをn種類の硬貨で両替する方法の数。ただしdは最初の硬貨の金額。

なんでかっていうと、両替する方法は次の2つに分けられることに注意。

* 最初の硬貨を1枚も使わない方法
* 最初の硬貨を少なくとも1枚は使う方法

1つめの場合の数はAと一緒だし、2つめの場合の数は1枚使って残りの金額をn種類で両替する方法と同じ。つまりBと同じだ。

Aの場合は硬貨の種類が減ってて、Bの場合はお金が減ってる。だからこのやり方で再帰的に問題をどんどん小さくしていくことができる。はしっこのケースはこうだ。

* もし a が 0 なら 1 通り
* a が 0 未満なら 0 通り
* n が 0 なら 0 通り

つまりこうなる。
```lisp
(define (count-change amount)
  (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
```
最初の問題の答えはこう。
```lisp
(count-change 100)
292
```
count-changeは木の再帰プロセスになって、フィボナッチと同じように効率はよくない。
でもアイデアをプログラムに翻訳するのは簡単だ。
同じことをする繰り返しプロセスのプログラムはどう書けばいいのかちょっと分からない。
だから将来誰かがかしこいコンパイラーを作って、木の再帰プロセスを繰り返しプロセスのプログラムに翻訳できるようになるかもしれない。

### 問題 1.11

関数fは、n&lt;=3 のとき f(n) = n、n&gt;3のとき f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3)とする。fを計算する手続きを、再帰的プロセスのものと繰り返しプロセスのものでそれぞれ作りなさい。

[回答](exercises/1.11.scm)

### 問題 1.12

次のようなのをパスカルの三角形という。
```lisp
    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1
```
再帰的プロセスでこれを計算する手続きを書きなさい。

[回答](exercises/1.12.scm)

### 問題 1.13

phiを黄金比=(1+root 5)/2として、Fib(n)が phi^n / root 5 に一番近い整数であることを証明しなさい。
ヒント：psi = (1-root 5)/2 として、Fib(n) = (phi^n - psi^n)/ root 5なことを示せ。

[回答](exercises/1.13.scm)

1.2.3 増加のオーダー
--------------------

計算のプロセスによって、ステップ数とか領域量の消費の仕方はぜんぜん違う。それを表すには増加のオーダーを使うのがいい。

nを問題のサイズ、R(n)を使うリソースの量とする。
なにをもって問題のサイズとするかは、問題の種類によって変わってくる。
フィボナッチ数列なら何番目か、ニュートン法での近似値計算なら求める桁数、行列計算なら行列の列の数とかが考えられる。
リソースの量も同様。レジスターの数かもしれないし、CPUの演算の回数かもしれない。一回のステップにやる演算の数が一定なら、計算にかかる時間は演算の数に比例する。

n によらない定数 k1 と k2があって、十分大きな任意のnに対してk1 f(n) &lt;= R(n) &lt;= kn f(n) となるとき、R(n) の増加のオーダーは &Theta;(f(n))だという。

ようするに f(n) とたかだか定数倍しか違わないってこと。

たとえば階乗の線形再帰プロセスでの計算のステップはnに比例してたので、オーダーは&Theta;(n)だ。領域量も &Theta;(n)だった。繰り返しプロセスだとステップは &Theta;(n) だけど領域はなんと &Theta;(1)だった。
木再帰プロセスだと &Theta;(&Phi;^n) で、領域量は &Theta;(n)だった。

オーダーはすごいおおざっぱな情報しか示さない。
n^2も 1000*n^2 も3*n^2 + 10*n + 17 もぜんぶ &Theta;(n^2)だ。
そのかわり、サイズが変わると必要なリソースがどう変わるかのいい指標になる。
&Theta;(n)ならnが2倍になればリソースも2倍だし、&Theta;(2^n)ならnが1増えるとリソースは2倍になる。&Theta;(log n)ならnが2倍になってもリソースは定数分増えるだけだ。

### 問題 1.14

両替の問題で11セントをやったときの計算プロセスがどうなるか描きなさい。
ステップと領域量のオーダーは？

[回答](exercises/1.14.scm)

### 問題 1.15

sin x を計算するためにはsin x = 3 sin (x/3) - 4 sin^3 (x/3)で sin の引数を小さくしていって、十分小さくなったらsin x ~ x の近似で sin x = xとしてやればいい。
```lisp
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
   (if (not (> (abs angle) 0.1))
       angle
       (p (sine (/ angle 3.0)))))
```
a. (sine 12.15) を評価すると p が何回適用されるか？b. (sine a)のステップ数と領域量のオーダーは？

[回答](exercises/1.15.scm)

1.2.4 べき乗
------------

べき乗の計算は普通に書くとこうなる。
```lisp
(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))
```
これは計算量がO(n)で領域量がO(n)。
繰り返しプロセスにするのも簡単。
```lisp
(define (expt b n)
  (expt-iter b n 1))

(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b
                (- counter 1)
                (* b product)))) 
```
こっちは計算量がO(n)で領域量はO(1)

ただし頭がいい方法があって、b^8 なら
```lisp
b^2 = b * b
b^4 = b^2 * b^2
b^8 = b^4 * b^4
```
みたいにすればかけ算は3回で住む。つまりO(log n)。
一般化すると、
```lisp
b^n = (b^(n/2))^2  ; b が偶数
b^n = b * b^(n-1)  ; b が奇数
```
となるから
```lisp
(define (fast-expt b n)
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        (else (* b (fast-expt b (- n 1))))))

(define (even? n)
  (= (remainder n 2) 0))
```
で計算できる。
繰り返しプロセスでも計算できるけど、再帰的な書き方みたいにまっすぐ書くのは難しい。

### 問題 1.16

fast-expt を繰り返しプロセスで書き直しなさい。
ヒント：最終的に答えを表すことになる変数を a として、aを1から始めて、ステップが進んでも a * b^n が一定となるようにaを変化させていく。その際に (b^(n/2))^2 = (b^2)^(n/2) を使う。

[回答](exercises/1.16.scm)

### 問題 1.17

かけ算は足し算の繰り返しで計算できる。こんなふうに。
```lisp
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
```
2倍にするdoubleと半分にするhalveを使って、fast-exptみたいにO(log n)なfast-multをつくりなさい。

[回答](exercises/1.17.scm)

### 問題 1.18

問題1.16と1.17の結果から、O(log n)でかけ算する繰り返しプロセスな手続きをつくりなさい。
adding, doubling, halving を使って。

[回答](exercises/1.18.scm)

### 問題 1.19

Fib(n)を賢く計算する方法がある。

* a &lt;- a + b
* b &lt;- a

な変換をTとすると、T^n(1,0) = (Fib(n+1),Fib(n))となる。
Tを一般化して T(p,q) として

* a &lt;- bq + aq + ap
* b &lt;- bp + aq

とすると、TはT(0,1)と同じ。

1. T^2(p,q) は T(P,Q) と同じなことを示せ。その際の P と Q は？
2. その結果を使って fib を以下のように定義したときの &lt;??&gt; を埋めなさい。

```lisp
(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   ??      ; compute p'
                   ??      ; compute q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
```
[回答](exercises/1.19.scm)

1.2.5 最大公約数
----------------

最大公約数を計算してみよう。
ユークリッドの互除法で。
```lisp
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
```
これのオーダーはO(log n)だ。
なんでかっていうと、kステップかかるとするとペアの小さい方はかならずFib(k)より大きいっていう定理があるので。

### 問題 1.20

正規順か適用順かで、計算プロセスはもちろん変わってくる。
(gcd 206 40)を正規順で計算したときの様子は？ remainderが評価される回数は？適用順の場合はどうか？

[回答](exercises/1.20.scm)
```lisp
```
1.2.6 例：素数の判別
--------------------

素数の判別をする O(root n)なアルゴリズムと、O(log n)な確率的アルゴリズムを紹介する。

約数を探す
----------

素数の判別をする方法の1つは約数を探すこと。
まっすぐ実装するとこうなる。
```lisp
(define (smallest-divisor n)
  (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b)
  (= (remainder b a) 0))
```
1から root nまで順に、nの約数かどうかを調べて最小の約数を探す。
```lisp
(define (prime? n)
  (= n (smallest-divisor n)))
```
で、nが素数かどうか判別できる。
O(root n)で。

フェルマーテスト
----------------

フェルマーの小定理っていうのがあって、それを使うと賢く判別できる。
「nを素数とすると、nより小さな任意の自然数aについて a^n = a(mod n)」

nが素数じゃない場合は、たいていのa&lt;nについて a^n != a(mod n)となる。
だから、nに対して適当なaを選んで a^n = a(mod n)かどうかをチェックして、偽なら素数じゃない、真なら違うaを選んでチェックを繰り返すと、どんどんnが素数である確率が高くなる。

最初に m を法とするべき乗を計算する手続きをつくる。
```lisp
(define (expmod base exp m) ; = base^exp (mod m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))       
```
さっきやった繰り返しプロセスで O(log n)で計算するやり方だ。
フェルマーテストを1回やる手続きはこう。
```lisp
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
```
(random N)は0以上N未満の乱数の自然数を返す。
ある回数連続してフェルマーテストに通ったら、素数とすることにしよう。
```lisp
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))
```
確率的な方法
------------

このやりかたは確率的だ。
テストに通らなかったら素数じゃないとはいえるけど、通ったから必ず素数だとは言えない。

じつはnが素数じゃないのに、a&lt;nなすべてのaについてテストが通る場合がある。むちゃくちゃレアだけど。だから全部のテストが通ったから必ず素数ともいえない。

こうならないような、フェルマーテストの変形がある。
まず a&lt;nをランダムにとって何かのテストをする。
このとき、任意のnについて、nが素数じゃないならほとんどのaについてテストが通らないことが証明できる。

だからnがテストに1回通ったら、nは50%以上の確率で素数だと言える。
2回通れば75%以上。というふうにどんどん確率が100%に近づいていくようにできる。

こういう確率的アルゴリズムはどんどん適用の幅を広げている。

### 問題 1.21

199, 1999, 19999 について、最小の約数を見つけなさい。smallest-devisor を使って。

[回答](exercises/1.21.scm)
```lisp
```
### 問題 1.22

runtime を使うと、実行時間を測定できる。
次のは、素数の判別結果を、かかった時間とともに表示する。
```lisp
(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))
```
これを使って、与えられた範囲の連続する奇数がそれぞれ素数かどうか判別するような手続き search-for-primes を書きなさい。
それを使って、1,000より大きな最小の素数を3つ見つけなさい。
同様に10,000以上、100,000以上, 1,000,000以上についても。
prime? は O(root n)なので、10,000は1,000のroot 10倍かかるか？100,000はどうか？

[回答](exercises/1.22.scm)

### 問題 1.23

smallest-divisorでは、2,3,4,5,6..みたいに約数の候補のチェックをするけど、2,3,5,7,9.. のほうがムダがない。そういうふうに書き換えなさい。
問題1.22ででてくる12の素数について、実行時間の改善を調べなさい実行時間は半分になりそうな気がするけどどうか？もし違うならその理由は？

[回答](exercises/1.23.scm)

### 問題 1.24

timed-prime-testを fast-prime? で書き換えなさい。
それで上の12の素数についてやってみなさい。
1000 に比べて 1,000,000 の時間はどうか？O(log n)に沿ってる？沿ってないなら理由は？

[回答](exercises/1.24.scm)

### 問題 1.25

expmode をこう書いたらだめ？
```lisp
(define (expmod base exp m)
  (remainder (fast-expt base exp) m))
```
[回答](exercises/1.25.scm)

### 問題 1.26

次の書き方ではうまく高速化しない。
```lisp
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (* (expmod base (/ exp 2) m)
                       (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))
```
具体的には O(log n)のはずが O(n) になる。なぜか？

[回答](exercises/1.26.scm)

### 問題 1.27

カーマイケル数がフェルマーテストを通ってしまうことを確認せよ。
カーマイケル数は、素数じゃないのにフェルマーテストを通る数。
例えば 561, 1105, 1729, 2465, 2821, 6601

[回答](exercises/1.27.scm)
