; 1.2 手続きと、それがつくるプロセス
; ==================================
; 
; これまでプログラムの要素をみてきたけど、これだけだとまだ
; プログラムの組み方が分かったことにはならい。チェスでいえば
; 駒の動かし方が分かっただけで、どういう動かし方がいいかが分からない。
;
; 達人になるには、何をどう動かしたらその結果何がどうなるかが完璧に
; 分かってないといけない。あらかじめ図示できるようじゃないといけない。
;
; 手続きは、計算のプロセスの局所的な進行のパターンだ。あるステージから
; 次のステップでどんなステージになるかを定める。
;
; この章では、かんたんな手続きについて、典型的な計算のプロセスの形を見てみよう。
; それから計算量とか領域量も。
;
; 1.2.1 線形再帰と繰り返し
; ------------------------
;
; 最初に階乗の計算プロセスを見てみよう

(factorial 6)
(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (factorial 3))))
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
720

; たとえばこんな感じだ。factorial はふつうに定義するとこうなる。

(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))

; もうちょっと違う計算方法もある。
; 1 * 2 * .. * n と1から順にnまでかけ算すればいい。
; こんな感じ。

(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))

; 計算のプロセスはこうだ。

(factorial 6)
(fact-iter   1 1 6)
(fact-iter   1 2 6)
(fact-iter   2 3 6)
(fact-iter   6 4 6)
(fact-iter  24 5 6)
(fact-iter 120 6 6)
(fact-iter 720 7 6)
720

; fact-iterの最初の引数に途中の答えが引き回されてる。2番めの引数はカウンターだ。
; ふたつの factorial は、同じ計算をする手続きなのにそのプロセスは全然違う。
; 
; 最初の例みたいに、最初に展開しまくって後から収束するタイプを再帰的プロセスという。
; 展開してる最中に必要な領域はnに比例するので、とくに線形再帰プロセスという。
;
; 2つめのほうは、必要な領域量はプロセスの最中ずっと一定だ。こういうのを繰り返し
; プロセスという。この手のプロセスの状態は状態変数と、それがどういうふうに
; 変化するか、どんな条件で繰り返しが終わるかで表せる。
; n!を計算するのに必要なステップはnなので、とくに線形繰り返しプロセスという。
